;
; 9032_project.asm
;
; Created: 2018/10/22 15:47:57
; Author : Ran Bai
; version Number: 1.0
; Replace with your application code
;------------------------------------------------------------------------------------------------------------
;Board settings(Designed): 5 parts
;	1.LED:
;	Three LEDs which stand for cup: LED0-2---->PORTC(PC0-2, respectively)
;	Four LEDs for indicator: LED6-9---->PORTB(PB0-PB3, respectively)
;	2.KeyPad:
;	C2-C0---->PORTC(PC7-PC5, respectively)
;	    R0---->PORTC(PC4)
;	3.Motor:
;	Ope---->any +5v
;	Mot---->PORTC(PC3)
;	4.LCD:
;	LCD DATA:D0-D7----->PORTF(PF0-PF7, respectively)
;	LCD CTRL:BE---->PA4
;	          RW---->PA5
;	          E------->PA6
;	          RS----->PA7
;	5.Interrupt:
;		INT0---->PB0
;------------------------------------------------------------------------------------------------------------
.include"m2560def.inc"
.def tmp1 = r16             ; tmp2:tmp1 is 1 bytes of temp register, used for storing temporarily
.def tmp2 = r17             ;
.def random_number = r18    ; store random number generated by Timer0
.def status = r19           ; define the status2 and status3, 0xFF stand for ball is shuffled, status 2
                            ;                                 0x00 stand for ball stop shuffled, status 3
.def score = r20            ; store user score in the game
.def control = r21          ; define control to r21, used for debouncing


; control other 4 LED on and off 
.macro other_LED_off
     ldi tmp1, 0x00
	 out PORTB, tmp1
.endmacro
.macro other_LED_on
     ldi tmp1, 0xFF
	 out PORTB, tmp1
.endmacro

; display the random number in the cup LED
.macro cup_led_display
		cpi random_number, 1
		brne not_1
		sbi PORTC, 0                     ; random_number = 1 ---> LED2 on, LED0, LED1 off
		cbi PORTC, 1
		cbi PORTC, 2
		;do_lcd_data '1'
		rjmp cup_end
	not_1:
		cpi random_number, 2
		brne not_2
		cbi PORTC, 0                     ; random_number = 2 ---> LED1 on, LED0, LED2 off
		sbi PORTC, 1
		cbi PORTC, 2
		;do_lcd_data '2'
		rjmp cup_end
	not_2:
		cbi PORTC, 0                     ; random_number = 3 ---> LED0 on, LED1, LED2 off
		cbi PORTC, 1
		sbi PORTC, 2
		;do_lcd_data '3'
	cup_end:
.endmacro

; LCD macro
.macro do_lcd_command
	ldi tmp1, @0
	rcall lcd_command
	rcall lcd_wait
.endmacro
.macro do_lcd_data
	ldi tmp1, @0
	rcall lcd_data
	rcall lcd_wait
.endmacro

.cseg
      jmp RESET
.org  INT0addr
      jmp EXT_INT0
.org OVF0addr
	  jmp Timer0OVF

RESET:
    ; defined register initial
    ldi random_number, 1                                 ; initial random number, set to 1
    clr score                                            ; score initial, clear to 0
	clr status                                           ; status inital, clear to 0x00, status used to sign which status it is. 2 or 3
	                                                     ;                status2: status = 0xFF, status3: status = 0x00

    ; LCD initial
	ldi tmp1, low(RAMEND)
	out SPL, tmp1
	ldi tmp1, high(RAMEND)
	out SPH, tmp1

	ser tmp1
	out DDRF, tmp1
	out DDRA, tmp1
	clr tmp1
	out PORTF, tmp1
	out PORTA, tmp1

	do_lcd_command 0b00111000 ; 2x5x7
	rcall sleep_5ms
	do_lcd_command 0b00111000 ; 2x5x7
	rcall sleep_1ms
	do_lcd_command 0b00111000 ; 2x5x7
	do_lcd_command 0b00111000 ; 2x5x7
	do_lcd_command 0b00001000 ; display off
	do_lcd_command 0b00000001 ; clear display
	do_lcd_command 0b00000110 ; increment, no display shift
	do_lcd_command 0b00001110 ; Cursor on, bar, no blink

	do_lcd_data 'R'
	do_lcd_data 'e'
	do_lcd_data 'a'
	do_lcd_data 'd'
	do_lcd_data 'y'
	do_lcd_data '.'
	do_lcd_data '.'
	do_lcd_data '.'
		
	; timer0 inital
	ldi tmp1, 0b00000000
	out TCCR0A, tmp1
	ldi tmp1, 0b00000011
	out TCCR0B, tmp1				; Prescaling value=64
	ldi tmp1, 1<<TOIE0				; =1024 microseconds
	sts TIMSK0, tmp1				; T/C0 interrupt enable

	; portG initial for dimmed_light
	clr tmp1
	out DDRG, tmp1                  ; set port G to input mode
	ser tmp1
	out PORTG, tmp1                 ; active pull-up resistor for input pin

	; INT0 interrupt initial
	ldi tmp1, (2 << ISC00)	        ; set INT0 as falling edge triggered interrupt
	sts EICRA, tmp1
	in tmp1, EIMSK		            ; enable INT0
	ori tmp1, (1<<INT0)
	out EIMSK, tmp1

	; Timer5 initial
	clr tmp1
	sts OCR5AH, tmp1
	ldi tmp1, 0x1A
	sts OCR5AL, tmp1              ; the value controls the PWM duty cycle

	ldi tmp1, (1 << CS50)         ; set Timer5 to Phase Correct PWM mode
	sts TCCR5B, tmp1
	ldi tmp1, (1 << WGM50)|(1 << COM5A1)
	sts TCCR5A, tmp1

	; enable the global interrupt
	sei		

	; port C inital, include motor, cup LED, and keypad. 0-->input, 1-->output
	ldi tmp1, 0b00011111
	out DDRC, tmp1

	; other LED initial, all pin of B set to output mode
	ldi tmp1, 0xFF
	out DDRB, tmp1
	out PORTB, tmp1

	cup_led_display            ; The cup LED with the ball is on
	jmp main

;-----------------------------------------Interrupt0-----------------------------------------------
EXT_INT0:
	; debouncing
		cpi control, 1
		brne through_interrupt
		com status                      
		cpi status, 0xFF                
		breq status_2                  ; if flag==0xFF, go to status 2, else status 3
	status_3:                          ; status3
		do_lcd_command 0b00000001      ; a. ¡°Start ¡­¡± is displayed on LCD;
		do_lcd_data '3'
                                       ; status change from 2 to 3
		cbi PORTC, 3                   ; a. The motor stops;
		

		rjmp end_interrupt             ; rjmp to end_interrupt
	status_2:                          ; status2
		do_lcd_command 0b00000001      ; a. ¡°Start ¡­¡± is displayed on LCD;
		do_lcd_data 'S'
		do_lcd_data 't'
		do_lcd_data 'a'
		do_lcd_data 'r'
		do_lcd_data 't'
		do_lcd_data '.'
		do_lcd_data '.'
		do_lcd_data '.'

		sbi PORTC, 3                  ; b. Motor spins;

		                              ; c. Three cup LEDs are all on, but in dimmed light; other LEDs remain off
	end_interrupt:
		clr control                    ; clear control
	through_interrupt:
		reti                           ; end interrupt and return

;--------------------------------------------Timer0----------------------------------------------
Timer0OVF:                         ; Timer0 used to generate random_number
		ldi tmp1, 1
		add random_number, tmp1
		cpi random_number, 4
		brne end_timer0
		ldi random_number, 1
	end_timer0:
		reti

;--------------------------------------------main-------------------------------------------------
main:
		cpi control, 1
		breq continue
		rcall sleep_150ms
		rcall sleep_150ms
		rcall sleep_150ms
		rcall sleep_150ms
		ldi control, 1
	continue:
		rjmp main

;------------------------------------------------------------------------------------
; LCD macro
.equ LCD_RS = 7
.equ LCD_E = 6
.equ LCD_RW = 5
.equ LCD_BE = 4

.macro lcd_set
	sbi PORTA, @0
.endmacro
.macro lcd_clr
	cbi PORTA, @0
.endmacro

;
; Send a command to the LCD (tmp1)
;

lcd_command:
	out PORTF, tmp1
	nop
	lcd_set LCD_E
	nop
	nop
	nop
	lcd_clr LCD_E
	nop
	nop
	nop
	ret

lcd_data:
	out PORTF, tmp1
	lcd_set LCD_RS
	nop
	nop
	nop
	lcd_set LCD_E
	nop
	nop
	nop
	lcd_clr LCD_E
	nop
	nop
	nop
	lcd_clr LCD_RS
	ret

lcd_wait:
	push tmp1
	clr tmp1
	out DDRF, tmp1
	out PORTF, tmp1
	lcd_set LCD_RW
lcd_wait_loop:
	nop
	lcd_set LCD_E
	nop
	nop
        nop
	in tmp1, PINF
	lcd_clr LCD_E
	sbrc tmp1, 7
	rjmp lcd_wait_loop
	lcd_clr LCD_RW
	ser tmp1
	out DDRF, tmp1
	pop tmp1
	ret

.equ F_CPU = 16000000
.equ DELAY_1MS = F_CPU / 4 / 1000 - 4
sleep_1ms:
	push r24
	push r25
	ldi r25, high(DELAY_1MS)
	ldi r24, low(DELAY_1MS)
delayloop_1ms:
	sbiw r25:r24, 1
	brne delayloop_1ms
	pop r25
	pop r24
	ret

sleep_5ms:
	rcall sleep_1ms
	rcall sleep_1ms
	rcall sleep_1ms
	rcall sleep_1ms
	rcall sleep_1ms
	ret

sleep_30ms:
    rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	ret

sleep_150ms:
    rcall sleep_30ms                          ; 30ms 
	rcall sleep_30ms                          ; 30ms
	rcall sleep_30ms                          ; 30ms
	rcall sleep_30ms                          ; 30ms
	rcall sleep_30ms                          ; 30ms
	ret