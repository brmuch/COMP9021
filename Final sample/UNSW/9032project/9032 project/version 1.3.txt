;
; 9032_project.asm
;
; Created: 2018/10/22 15:47:57
; Author : Ran Bai
; version Number: 1.0
; Replace with your application code
;------------------------------------------------------------------------------------------------------------
;Board settings(Designed): 5 parts
;	1.LED:
;	Three LEDs which stand for cup: LED0-2---->PORTC(PC0-2, respectively)
;	Four LEDs for indicator: LED6-9---->PORTB(PB0-PB3, respectively)
;	2.KeyPad:
;	C2-C0---->PORTC(PC7-PC5, respectively)
;	    R0---->PORTC(PC4)
;	3.Motor:
;	Ope---->any +5v
;	Mot---->PORTC(PC3)
;	4.LCD:
;	LCD DATA:D0-D7----->PORTF(PF0-PF7, respectively)
;	LCD CTRL:BE---->PA4
;	          RW---->PA5
;	          E------->PA6
;	          RS----->PA7
;	5.Interrupt:
;		INT0---->PB0
;------------------------------------------------------------------------------------------------------------
.include"m2560def.inc"
.def tmp1 = r16             ; tmp2:tmp1 is 1 bytes of temp register, used for storing temporarily
.def tmp2 = r17             ;
.def random_number = r18    ; store random number generated by Timer0
.def status = r19           ; define the status2 and status3, 0xFF stand for ball is shuffled, status 2
                            ;                                 0x00 stand for ball stop shuffled, status 3
.def score = r20            ; store user score in the game
.def control = r21          ; define control to r21, used for debouncing
.def is_dimmed_light = r22  ; define is_dimmed_light to r22, used for determining whether output dimmed light
.def kb_input = r23         ; define kb_input to r23, used for storing the number of keypad input. 1/2/3
.def ball_shuffle = r2      ; define ball_shuffle to r2, used for control random number generate or not, 0x00:dont shuffle, 0xFF:shuffle
.def is_read_keypad = r3              ; used for determining if read_keypad

; control other 4 LED on and off 
.macro other_LED_off
     ldi tmp1, 0x00
	 out PORTB, tmp1
.endmacro
.macro other_LED_on
     ldi tmp1, 0xFF
	 out PORTB, tmp1
.endmacro

.macro read_kb
	read:
        sbi PORTC, 4
		cbi PORTC, 5
		sbi PORTC, 6
		sbi PORTC, 7
        ldi kb_input, 1

		ldi tmp1, 0xFF                        ; slow down the scan operation.
    delay1:
	    dec tmp1
		brne delay1

		sbis PINC, 4                          ; determine if press '1', end loop
		rjmp convert

		sbi PORTC, 4
		sbi PORTC, 5
		cbi PORTC, 6
		sbi PORTC, 7
		ldi kb_input, 2
		
		ldi tmp1, 0xFF                        ; slow down the scan operation.
    delay2:
	    dec tmp1
		brne delay2

		sbis PINC, 4                          ; determine if press '2', end loop
		rjmp convert

		sbi PORTC, 4
		sbi PORTC, 5
		sbi PORTC, 6
		cbi PORTC, 7
		ldi kb_input, 3

		ldi tmp1, 0xFF                        ; slow down the scan operation.
    delay3:
	    dec tmp1
		brne delay3

		sbis PINC, 4                          ; determine if press '3', end loop
		rjmp convert
		jmp read
	convert:
.endmacro

; display the random number in the cup LED
.macro cup_led_display
		cpi random_number, 1
		brne not_1
		sbi PORTC, 0                     ; random_number = 1 ---> LED2 on, LED0, LED1 off
		cbi PORTC, 1
		cbi PORTC, 2
		do_lcd_data '1'
		rjmp cup_end
	not_1:
		cpi random_number, 2
		brne not_2
		cbi PORTC, 0                     ; random_number = 2 ---> LED1 on, LED0, LED2 off
		sbi PORTC, 1
		cbi PORTC, 2
		do_lcd_data '2'
		rjmp cup_end
	not_2:
		cbi PORTC, 0                     ; random_number = 3 ---> LED0 on, LED1, LED2 off
		cbi PORTC, 1
		sbi PORTC, 2
		do_lcd_data '3'
	cup_end:
.endmacro

; LCD macro
.macro do_lcd_command
	ldi tmp1, @0
	rcall lcd_command
	rcall lcd_wait
.endmacro
.macro do_lcd_data
	ldi tmp1, @0
	rcall lcd_data
	rcall lcd_wait
.endmacro

.cseg
      jmp RESET
.org  INT0addr
      jmp EXT_INT0
.org OVF0addr
	  jmp Timer0OVF

RESET:
    ; defined register initial
    ldi random_number, 1                                 ; initial random number, set to 1
    clr score                                            ; score initial, clear to 0
	clr status                                           ; status inital, clear to 0x00, status used to sign which status it is. 2 or 3
	                                                     ;                status2: status = 0xFF, status3: status = 0x00
    clr is_dimmed_light                                  ; is_dimmed_light = 0x00: dont display dimmed light
	                                                     ; is_dimmed_light = 0xFF: display dimmed light
    clr kb_input                                         ; clear kb_input
	clr ball_shuffle                                     ; clear ball_shuffle
	clr is_read_keypad                                   ; clear is_read_keypad, means dont need to read keypad, when it is 1, read keypad

    ; LCD initial
	ldi tmp1, low(RAMEND)
	out SPL, tmp1
	ldi tmp1, high(RAMEND)
	out SPH, tmp1

	ser tmp1
	out DDRF, tmp1
	out DDRA, tmp1
	clr tmp1
	out PORTF, tmp1
	out PORTA, tmp1

	do_lcd_command 0b00111000 ; 2x5x7
	rcall sleep_5ms
	do_lcd_command 0b00111000 ; 2x5x7
	rcall sleep_1ms
	do_lcd_command 0b00111000 ; 2x5x7
	do_lcd_command 0b00111000 ; 2x5x7
	do_lcd_command 0b00001000 ; display off
	do_lcd_command 0b00000001 ; clear display
	do_lcd_command 0b00000110 ; increment, no display shift
	do_lcd_command 0b00001110 ; Cursor on, bar, no blink

	do_lcd_data 'R'
	do_lcd_data 'e'
	do_lcd_data 'a'
	do_lcd_data 'd'
	do_lcd_data 'y'
	do_lcd_data '.'
	do_lcd_data '.'
	do_lcd_data '.'
		
	; timer0 inital
	ldi tmp1, 0b00000000
	out TCCR0A, tmp1
	ldi tmp1, 0b00000001
	out TCCR0B, tmp1				; Prescaling value=64
	ldi tmp1, 1<<TOIE0				; =1024 microseconds
	sts TIMSK0, tmp1				; T/C0 interrupt enable

	; portG initial for dimmed_light
	clr tmp1
	out DDRG, tmp1                  ; set port G to input mode
	ser tmp1
	out PORTG, tmp1                 ; active pull-up resistor for input pin

	; INT0 interrupt initial
	ldi tmp1, (2 << ISC00)	        ; set INT0 as falling edge triggered interrupt
	sts EICRA, tmp1
	in tmp1, EIMSK		            ; enable INT0
	ori tmp1, (1<<INT0)
	out EIMSK, tmp1

	; Timer5 initial
	ldi tmp1, 0b00001000
    sts DDRL, tmp1                 ; Bit 3 will function as OC5A.

	clr tmp1
	sts OCR5AH, tmp1
	ldi tmp1, 0x2A
	sts OCR5AL, tmp1              ; the value controls the PWM duty cycle

	ldi tmp1, (1 << CS50)         ; set Timer5 to Phase Correct PWM mode
	sts TCCR5B, tmp1
	ldi tmp1, (1 << WGM50)|(1 << COM5A1)
	sts TCCR5A, tmp1

	; enable the global interrupt
	sei		

	; port C inital, include motor, cup LED, and keypad. 0-->input, 1-->output
	ldi tmp1, 0b11101111
	out DDRC, tmp1

	; other LED initial, all pin of B set to output mode
	ldi tmp1, 0xFF
	out DDRB, tmp1
	out PORTB, tmp1

	cup_led_display            ; The cup LED with the ball is on
	jmp main

;-----------------------------------------Interrupt0-----------------------------------------------
EXT_INT0:
	; debouncing
		cpi control, 1
		breq can_next 
		jmp through_interrupt
	can_next:
		com status                      
		cpi status, 0xFF                
		brne status_3                  ; if flag==0xFF, go to status 2, else status 3
		jmp status_2
	status_3:                          ; status3
			clr ball_shuffle               ; clear ball_shuffle, ball stop shuffle
			do_lcd_command 0b00000001      ; a. ¡°guess¡­¡± is displayed on LCD;
			do_lcd_data 'G'                ; status change from 2 to 3
			do_lcd_data 'u'
			do_lcd_data 'e'
			do_lcd_data 's'
			do_lcd_data 's'
			do_lcd_data '.'
			do_lcd_data '.'
			do_lcd_data '.'
			cbi PORTC, 3                   ; a. The motor stops;
										   ; b. The three cup LEDs remain dimmed
			ldi tmp1, 1
			mov is_read_keypad, tmp1       ; read_keypad and subsequent operation
			rjmp end_interrupt             ; rjmp to end_interrupt

	status_2:                          ; status2
			ldi tmp1, 0xFF
			mov ball_shuffle, tmp1         ; ball start shuffle
			do_lcd_command 0b00000001      ; a. ¡°Start ¡­¡± is displayed on LCD;
			do_lcd_data 'S'
			do_lcd_data 't'
			do_lcd_data 'a'
			do_lcd_data 'r'
			do_lcd_data 't'
			do_lcd_data '.'
			do_lcd_data '.'
			do_lcd_data '.'

			sbi PORTC, 3                  ; b. Motor spins;

			ldi is_dimmed_light, 0xFF     ; c. Three cup LEDs are all on, but in dimmed light; other LEDs remain off
		end_interrupt:
			clr control                   ; clear control
		through_interrupt:
			reti                          ; end interrupt and return

;--------------------------------------------Timer0----------------------------------------------
Timer0OVF:                         ; Timer0 used to generate random_number(1ms)
        ldi tmp1, 0xFF
		cp tmp1, ball_shuffle
		brne end_timer0
		inc random_number
		cpi random_number, 4
		brne end_timer0
		ldi random_number, 1
	end_timer0:
	    ldi tmp1, 0xFF
		cp is_dimmed_light, tmp1
		brne not_dimmed
							  ; status 2/3, if status 3, press keypad and jump out loop
		sbic PING, 0
		sbi PORTC, 0
		sbic PING, 0
		sbi PORTC, 1
		sbic PING, 0
		sbi PORTC, 2
		
		sbis PING, 0
		cbi PORTC, 0
		sbis PING, 0
		cbi PORTC, 1
		sbis PING, 0
		cbi PORTC, 2
	not_dimmed:
		reti

;--------------------------------------------main-------------------------------------------------
main:
		cpi control, 1
		breq continue
		rcall sleep_150ms
		rcall sleep_150ms
		rcall sleep_150ms
		ldi control, 1

		cpi status, 0xFF
		breq continue
		ldi tmp1, 1
		cp is_read_keypad, tmp1
	    brne next_loop
		read_kb
		ldi tmp1, '0'
		add kb_input, tmp1
		ldi tmp1, '1'
		cp tmp1, kb_input
		brne not_1
		do_lcd_data '1'
		rjmp finish_display
    not_1:
	    ldi tmp1, '2'
		cp tmp1, kb_input
		brne not_2
		do_lcd_data '2'
		rjmp finish_display
	not_2:
	    do_lcd_data '3'
	finish_display:
	    clr is_read_keypad
	next_loop:
	continue:
	   
		rjmp main
;------------------------------------------------------------------------------------
; LCD macro
.equ LCD_RS = 7
.equ LCD_E = 6
.equ LCD_RW = 5
.equ LCD_BE = 4

.macro lcd_set
	sbi PORTA, @0
.endmacro
.macro lcd_clr
	cbi PORTA, @0
.endmacro

;
; Send a command to the LCD (tmp1)
;

lcd_command:
	out PORTF, tmp1
	nop
	lcd_set LCD_E
	nop
	nop
	nop
	lcd_clr LCD_E
	nop
	nop
	nop
	ret

lcd_data:
	out PORTF, tmp1
	lcd_set LCD_RS
	nop
	nop
	nop
	lcd_set LCD_E
	nop
	nop
	nop
	lcd_clr LCD_E
	nop
	nop
	nop
	lcd_clr LCD_RS
	ret

lcd_wait:
	push tmp1
	clr tmp1
	out DDRF, tmp1
	out PORTF, tmp1
	lcd_set LCD_RW
lcd_wait_loop:
	nop
	lcd_set LCD_E
	nop
	nop
        nop
	in tmp1, PINF
	lcd_clr LCD_E
	sbrc tmp1, 7
	rjmp lcd_wait_loop
	lcd_clr LCD_RW
	ser tmp1
	out DDRF, tmp1
	pop tmp1
	ret

.equ F_CPU = 16000000
.equ DELAY_1MS = F_CPU / 4 / 1000 - 4
sleep_1ms:
	push r24
	push r25
	ldi r25, high(DELAY_1MS)
	ldi r24, low(DELAY_1MS)
delayloop_1ms:
	sbiw r25:r24, 1
	brne delayloop_1ms
	pop r25
	pop r24
	ret

sleep_5ms:
	rcall sleep_1ms
	rcall sleep_1ms
	rcall sleep_1ms
	rcall sleep_1ms
	rcall sleep_1ms
	ret

sleep_30ms:
    rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	rcall sleep_5ms                           ; 5ms
	ret

sleep_150ms:
    rcall sleep_30ms                          ; 30ms 
	rcall sleep_30ms                          ; 30ms
	rcall sleep_30ms                          ; 30ms
	rcall sleep_30ms                          ; 30ms
	rcall sleep_30ms                          ; 30ms
	ret